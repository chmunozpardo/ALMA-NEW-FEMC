/*! \file   compressor.c
    \brief  FETIM Compressor

    <b> File information: </b><br>
    Created: 2011/03/28 17:34:50 by avaccari

    This file contains all the functions necessary to handle FETIM compressor
    events. */

/* Includes */
#include <stdio.h>      /* printf */

#include "frontend.h"
#include "debug.h"
#include "error_local.h"
#include "fetimSerialInterface.h"

/* Globals */
unsigned char   currentCompressorModule=0;
/* Statics */
static HANDLER compressorModulesHandler[COMPRESSOR_MODULES_NUMBER]={fetimExtTempHandler,
                                                                    fetimExtTempHandler,
                                                                    he2PressHandler,
                                                                    feStatusHandler,
                                                                    interlockStatusHandler,
                                                                    compCableStatusHandler};

/* Compressor Handler */
/*! This function will be called by the CAN message handler when the received
    message is in the address range of the compressor */
void compressorHandler(void){
    #ifdef DEBUG_FETIM
        printf("  Compressor\n");
    #endif /* DEBUG_FETIM */

    /* Check if the specified submodule is in range */
    currentCompressorModule=(CAN_ADDRESS&COMPRESSOR_MODULES_RCA_MASK)>>COMPRESSOR_MODULES_MASK_SHIFT;
    if(currentCompressorModule>=COMPRESSOR_MODULES_NUMBER){
        storeError(ERR_COMPRESSOR, ERC_MODULE_RANGE); //Submodule out of range
        CAN_STATUS = HARDW_RNG_ERR; // Notify incoming CAN message of error
        return;
    }

    /* Call the correct function */
    (compressorModulesHandler[currentCompressorModule])();

    return;

}


/* FE status handler */
/* This function deals with the monitor requests to the FE status handler. This
   represent the current status of the FE as evaluated by the FEMC. It will
   signal to the FETIM if, according to the FEMC, it is ok to start the
   comrpessor. */
static void feStatusHandler(void){

    #ifdef DEBUG_FETIM
        printf("   FE Status\n");
    #endif /* DEBUG_FETIM */


    /* If control (size !=0) store error and return. No control messages are
       allowed on this RCA. */
    if(CAN_SIZE){
        storeError(ERR_COMPRESSOR, ERC_RCA_RANGE); //Control message out of range
        return;
    }

    /* If monitor on control RCA return error since there are no control messages
       allowed on the RCA. */
    if(currentClass==CONTROL_CLASS){ // If monitor on a control RCA
        storeError(ERR_COMPRESSOR, ERC_RCA_RANGE); //Monitor message out of range
        /* Store the state in the outgoing CAN message */
        CAN_STATUS = MON_CAN_RNG;

        return;
    }

    /* If Monitor on a Monitor RCA */
    /* This value is generated by the FEMC in the asynch loop. It is always
       available and not obtained by a monitor operation on some hardware. */
    CAN_BYTE=frontend.
              fetim.
               compressor.
                feStatus;

    /* No check against limit is necessary (see above). */

    /* The CAN message payload is already loaded. Set the size */
    CAN_SIZE=CAN_BOOLEAN_SIZE;
}

/* Interlock status handler */
/* This function return the current status of the compressor interlock */
static void interlockStatusHandler(void){

    #ifdef DEBUG_FETIM
        printf("   Interlock Status Handler\n");
    #endif /* DEBUG_FETIM */

    /* If control (size !=0) store error and return. No control messages are
       allowed on this RCA. */
    if(CAN_SIZE){
        storeError(ERR_COMPRESSOR, ERC_RCA_RANGE); //Control message out of range
        return;
    }

    /* If monitor on control RCA return error since there are no control messages
       allowed on the RCA. */
    if(currentClass==CONTROL_CLASS){ // If monitor on a control RCA
        storeError(ERR_COMPRESSOR, ERC_RCA_RANGE); //Monitor message out of range
        /* Store the state in the outgoing CAN message */
        CAN_STATUS = MON_CAN_RNG;

        return;
    }

    /* If Monitor on a Monitor RCA */
    /* Monitor Single Fail digital line */
    if(getFetimDigital(FETIM_DIG_INTRLK_STA)==ERROR) {
        /* If error during monitoring, store the ERROR state in the outgoing
           CAN message state. */
        CAN_STATUS = ERROR;
    }

    /* Store the last monitored value in the outgoing message */
    CAN_BYTE=frontend.
              fetim.
               compressor.
                intrlkStatus;

    /* The CAN message payload is already loaded. Set the size */
    CAN_SIZE=CAN_BOOLEAN_SIZE;
}

/* Compressor cable status handler */
/* This function return the current status of the compressor cable */
static void compCableStatusHandler(void){

    #ifdef DEBUG_FETIM
        printf("   Compressor Cable Status Handler\n");
    #endif /* DEBUG_FETIM */

    /* If control (size !=0) store error and return. No control messages are
       allowed on this RCA. */
    if(CAN_SIZE){
        storeError(ERR_COMPRESSOR, ERC_RCA_RANGE); //Control message out of range
        return;
    }

    /* If monitor on control RCA return error since there are no control messages
       allowed on the RCA. */
    if(currentClass==CONTROL_CLASS){ // If monitor on a control RCA
        storeError(ERR_COMPRESSOR, ERC_RCA_RANGE); //Monitor message out of range
        /* Store the state in the outgoing CAN message */
        CAN_STATUS = MON_CAN_RNG;
        return;
    }

    /* If Monitor on a Monitor RCA */
    /* Monitor Single Fail digital line */
    if(getFetimDigital(FETIM_DIG_COMP_CBL_STA)==ERROR){
        /* If error during monitoring, store the ERROR state in the outgoing
           CAN message state. */
        CAN_STATUS = ERROR;
        /* Store the last known value in the outgoing message */
        CAN_BYTE=frontend.
                  fetim.
                   compressor.
                    cableStatus;

        /* Check the result against the warning and error range. Right now this
           function is only printing out a warning/error message depending on
           the result but no actions are taken. */
    } else {
        /* If no error during monitor process, gather the stored data/ */
        CAN_BYTE=frontend.
                  fetim.
                   compressor.
                    cableStatus;
    }

    /* The CAN message payload is already loaded. Set the size */
    CAN_SIZE=CAN_BOOLEAN_SIZE;
}
